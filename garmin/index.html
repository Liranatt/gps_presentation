<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Garmin Health Intelligence | Liran Attar</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet" />
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    :root {
      --bg: #0a0a0f;
      --bg-soft: #0d1117;
      --surface: rgba(255, 255, 255, 0.03);
      --surface-2: rgba(255, 255, 255, 0.04);
      --text: #ffffff;
      --text-dim: rgba(255, 255, 255, 0.45);
      --line: rgba(255, 255, 255, 0.08);
      --brand: #00f5a0;
      --brand-dark: #00d9f5;
      --brand-soft: rgba(0, 245, 160, 0.14);
      --warn-soft: rgba(245, 197, 66, 0.18);
      --warn-text: #f5c542;
      --bad-soft: rgba(245, 87, 108, 0.18);
      --bad-text: #f5576c;
      --radius-lg: 22px;
      --radius-md: 14px;
      --shadow-lg: 0 22px 60px -28px rgba(0, 0, 0, 0.65);
      --shadow-md: 0 12px 28px -20px rgba(0, 0, 0, 0.55);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Inter", sans-serif;
      background:
        radial-gradient(circle at 15% 0%, rgba(0, 245, 160, 0.16) 0%, transparent 40%),
        radial-gradient(circle at 85% 0%, rgba(102, 126, 234, 0.18) 0%, transparent 34%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    .page {
      width: min(1200px, calc(100% - 32px));
      margin: 18px auto 36px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 18px;
      padding: 10px 0;
    }

    .topbar-links {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .chip-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.04);
      color: rgba(255, 255, 255, 0.72);
      text-decoration: none;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      transition: all 0.2s ease;
    }

    .chip-link:hover {
      border-color: rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.09);
      color: #fff;
      transform: translateY(-1px);
    }

    .hero {
      background: linear-gradient(140deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.02) 52%, rgba(255,255,255,0.04) 100%);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      padding: 24px;
      margin-bottom: 16px;
      position: relative;
      overflow: hidden;
    }

    .hero::after {
      content: "";
      position: absolute;
      top: -80px;
      right: -80px;
      width: 220px;
      height: 220px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0, 245, 160, 0.28) 0%, transparent 70%);
      pointer-events: none;
    }

    .hero-inner {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: 1.35fr 1fr;
      gap: 16px;
      align-items: center;
    }

    .hero h1 {
      font-family: "Space Grotesk", sans-serif;
      font-size: clamp(28px, 4.8vw, 44px);
      line-height: 1.05;
      letter-spacing: -1px;
      margin-bottom: 10px;
      color: #fff;
    }

    .hero p {
      color: rgba(255, 255, 255, 0.68);
      font-size: 15px;
      line-height: 1.6;
      max-width: 64ch;
    }

    .hero-kpis {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .hero-kpi {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      padding: 12px;
      min-height: 86px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      text-align: center;
    }

    .hero-kpi .label {
      font-size: 11px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.45);
      margin-bottom: 5px;
      font-weight: 700;
    }

    .hero-kpi .value {
      font-size: 23px;
      font-weight: 800;
      line-height: 1;
      color: #fff;
    }

    .mode-nav {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 14px;
    }

    .mode-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: rgba(255, 255, 255, 0.75);
      text-decoration: none;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      transition: all 0.2s ease;
    }

    .mode-pill:hover {
      border-color: rgba(0, 245, 160, 0.38);
      color: #ffffff;
      background: rgba(0, 245, 160, 0.08);
      transform: translateY(-1px);
    }

    .mode-pill.is-active {
      border-color: rgba(0, 245, 160, 0.42);
      color: #fff;
      background: rgba(0, 245, 160, 0.14);
      box-shadow: inset 0 0 0 1px rgba(0, 245, 160, 0.2);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.18fr) minmax(0, 0.82fr);
      gap: 16px;
    }

    .stack {
      display: grid;
      gap: 16px;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      backdrop-filter: blur(12px);
      overflow: hidden;
    }

    .card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--line);
      background: var(--surface-2);
    }

    .card-title {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: "Space Grotesk", sans-serif;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: -0.2px;
      color: #fff;
    }

    .status {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      min-width: 120px;
      text-align: center;
      border: 1px solid transparent;
    }

    .status.loading {
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.68);
      border-color: rgba(255, 255, 255, 0.14);
    }

    .status.ok {
      background: var(--brand-soft);
      color: var(--brand-dark);
      border-color: rgba(0, 245, 160, 0.35);
    }

    .status.warm {
      background: var(--warn-soft);
      color: var(--warn-text);
      border-color: rgba(245, 197, 66, 0.35);
    }

    .status.fail {
      background: var(--bad-soft);
      color: var(--bad-text);
      border-color: rgba(245, 87, 108, 0.35);
    }

    .card-body {
      padding: 16px;
    }

    .settings-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr auto;
      align-items: end;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      font-size: 12px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.55);
      letter-spacing: 0.3px;
    }

    .field input {
      width: 100%;
      padding: 11px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 14px;
      outline: none;
    }

    .field input:focus {
      border-color: rgba(0, 245, 160, 0.45);
      box-shadow: 0 0 0 3px rgba(0, 245, 160, 0.13);
    }

    .button {
      border: none;
      border-radius: 10px;
      padding: 11px 14px;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      text-align: center;
      transition: all 0.2s ease;
      text-decoration: none;
      white-space: nowrap;
    }

    .button.primary {
      background: var(--brand);
      color: #fff;
    }

    .button.primary:hover {
      background: var(--brand-dark);
      transform: translateY(-1px);
    }

    .button.ghost {
      background: rgba(255, 255, 255, 0.05);
      color: rgba(255, 255, 255, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.13);
    }

    .button.ghost:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .help {
      margin-top: 8px;
      color: rgba(255, 255, 255, 0.55);
      font-size: 12px;
      line-height: 1.5;
    }

    .metrics-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .metric {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 14px;
      padding: 13px;
      background: rgba(255, 255, 255, 0.04);
      min-height: 104px;
      display: grid;
      align-content: center;
      justify-items: center;
      text-align: center;
    }

    .metric-label {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.3px;
      margin-bottom: 6px;
      font-weight: 700;
    }

    .metric-value {
      font-family: "Space Grotesk", sans-serif;
      font-size: 30px;
      line-height: 1;
      font-weight: 700;
      color: #fff;
    }

    .metric-meta {
      margin-top: 5px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.45);
    }

    .trend-status {
      margin-bottom: 10px;
    }

    .trend-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .analytics-toolbar {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr auto;
      align-items: center;
      margin-bottom: 12px;
    }

    .analytics-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .analytics-tab {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.04);
      color: rgba(255, 255, 255, 0.72);
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.3px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .analytics-tab:hover {
      border-color: rgba(0, 245, 160, 0.35);
      color: #fff;
      background: rgba(0, 245, 160, 0.08);
    }

    .analytics-tab.is-active {
      border-color: rgba(0, 245, 160, 0.45);
      color: #fff;
      background: rgba(0, 245, 160, 0.14);
      box-shadow: inset 0 0 0 1px rgba(0, 245, 160, 0.2);
    }

    .analytics-side {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-self: end;
    }

    .analytics-side label {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.56);
      font-weight: 700;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .analytics-side select {
      appearance: none;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 10px;
      color: #fff;
      font-size: 12px;
      font-weight: 700;
      padding: 8px 30px 8px 10px;
      min-width: 120px;
      outline: none;
    }

    .analytics-panel[hidden] {
      display: none !important;
    }

    .trend-card {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      padding: 10px;
      display: grid;
      gap: 7px;
    }

    .trend-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
    }

    .trend-label {
      font-size: 12px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 0.3px;
    }

    .trend-value {
      font-family: "Space Grotesk", sans-serif;
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      line-height: 1;
    }

    .spark {
      width: 100%;
      height: 68px;
      border-radius: 9px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .spark path {
      fill: none;
      stroke: var(--brand);
      stroke-width: 2.2;
      stroke-linejoin: round;
      stroke-linecap: round;
    }

    .spark circle {
      fill: #fff;
      stroke: var(--brand);
      stroke-width: 1.7;
    }

    .trend-delta {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .trend-delta.up {
      color: #4ade80;
    }

    .trend-delta.down {
      color: #fb7185;
    }

    .trend-delta.flat {
      color: rgba(255, 255, 255, 0.5);
    }

    .insights {
      display: grid;
      gap: 10px;
    }

    .insight-main {
      border: 1px solid rgba(0, 245, 160, 0.28);
      border-radius: 14px;
      padding: 14px;
      background: linear-gradient(135deg, rgba(0, 245, 160, 0.12) 0%, rgba(102, 126, 234, 0.08) 100%);
      margin-bottom: 10px;
      display: grid;
      gap: 8px;
    }

    .insight-main h3 {
      font-family: "Space Grotesk", sans-serif;
      font-size: 16px;
      color: #fff;
      letter-spacing: -0.2px;
    }

    .insight-main p {
      font-size: 14px;
      line-height: 1.65;
      color: rgba(255, 255, 255, 0.9);
    }

    .insight-main .meta {
      font-size: 12px;
      font-weight: 700;
      color: rgba(255, 255, 255, 0.62);
    }

    .insight {
      border: 1px solid rgba(255, 255, 255, 0.11);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      display: grid;
      gap: 6px;
    }

    .insight-top {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .insight-agent {
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: var(--brand);
      background: var(--brand-soft);
      border: 1px solid rgba(0, 245, 160, 0.22);
      padding: 4px 8px;
      border-radius: 999px;
    }

    .insight-time {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.48);
      font-weight: 700;
    }

    .insight p {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.82);
      line-height: 1.6;
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-clamp: 4;
    }

    .insight-detail {
      border-top: 1px dashed rgba(255, 255, 255, 0.14);
      padding-top: 8px;
    }

    .insight-detail summary {
      cursor: pointer;
      color: rgba(255, 255, 255, 0.65);
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      list-style: none;
    }

    .insight-detail summary::-webkit-details-marker {
      display: none;
    }

    .insight-detail pre {
      margin-top: 8px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.02);
      color: rgba(255, 255, 255, 0.74);
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      max-height: 220px;
      overflow: auto;
    }

    .empty {
      color: rgba(255, 255, 255, 0.52);
      font-size: 13px;
      text-align: center;
      padding: 8px;
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.03);
    }

    .chat-wrap {
      display: grid;
      gap: 10px;
      min-height: 0;
      grid-template-rows: auto auto auto;
    }

    #chat {
      align-self: start;
      position: sticky;
      top: 16px;
      height: fit-content;
    }

    .chat-log {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.04);
      padding: 12px;
      overflow: auto;
      display: grid;
      gap: 10px;
      min-height: 170px;
      max-height: min(42vh, 340px);
    }

    .msg {
      max-width: 92%;
      padding: 10px 11px;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.6;
      word-break: break-word;
      border: 1px solid transparent;
    }

    .msg.user {
      justify-self: end;
      background: rgba(102, 126, 234, 0.16);
      border-color: rgba(102, 126, 234, 0.34);
      color: #fff;
      border-bottom-right-radius: 5px;
    }

    .msg.bot {
      justify-self: start;
      background: rgba(0, 245, 160, 0.1);
      border-color: rgba(0, 245, 160, 0.25);
      color: rgba(255, 255, 255, 0.9);
      border-bottom-left-radius: 5px;
    }

    .msg.system {
      justify-self: center;
      background: rgba(245, 197, 66, 0.12);
      border-color: rgba(245, 197, 66, 0.3);
      color: #f5c542;
      text-align: center;
      max-width: 100%;
      font-size: 12px;
      padding: 8px 10px;
    }

    .chat-form {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
    }

    .chat-form textarea {
      min-height: 44px;
      max-height: 92px;
      resize: vertical;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 12px;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.45;
      color: var(--text);
      background: rgba(255, 255, 255, 0.04);
      outline: none;
    }

    .chat-form textarea:focus {
      border-color: rgba(0, 245, 160, 0.45);
      box-shadow: 0 0 0 3px rgba(0, 245, 160, 0.13);
    }

    .chat-actions {
      display: grid;
      gap: 8px;
      align-content: stretch;
      min-width: 120px;
    }

    .footer-note {
      margin-top: 12px;
      color: rgba(255, 255, 255, 0.48);
      font-size: 12px;
      text-align: center;
      line-height: 1.5;
    }

    .loading-row {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 13px;
      font-weight: 700;
    }

    .table-wrap {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      overflow: auto;
      max-height: 380px;
    }

    table {
      width: 100%;
      min-width: 760px;
      border-collapse: collapse;
    }

    thead th {
      position: sticky;
      top: 0;
      background: rgba(13, 17, 23, 0.95);
      backdrop-filter: blur(6px);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: rgba(255, 255, 255, 0.55);
      font-weight: 700;
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
    }

    th,
    td {
      padding: 9px 11px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      vertical-align: top;
    }

    tbody td {
      color: rgba(255, 255, 255, 0.82);
    }

    tbody tr:hover {
      background: rgba(255, 255, 255, 0.04);
    }

    .corr-cell {
      text-align: center;
      font-weight: 700;
    }

    .spin {
      animation: spin 0.9s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 1000px) {
      .hero-inner,
      .layout {
        grid-template-columns: 1fr;
      }

      #chat {
        position: static;
        top: auto;
      }

      .chat-wrap {
        min-height: 0;
      }

      .chat-log {
        max-height: 420px;
      }

      .analytics-toolbar {
        grid-template-columns: 1fr;
      }

      .analytics-side {
        justify-self: stretch;
      }
    }

    @media (max-width: 720px) {
      .page {
        width: calc(100% - 16px);
        margin-top: 10px;
      }

      .hero,
      .card-body {
        padding: 14px;
      }

      .card-head {
        padding: 11px 14px;
      }

      .hero-kpis,
      .metrics-grid,
      .trend-grid {
        grid-template-columns: 1fr;
      }

      .settings-grid,
      .chat-form {
        grid-template-columns: 1fr;
      }

      .chat-actions {
        min-width: 0;
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .button {
        width: 100%;
      }

      .chat-log {
        min-height: 220px;
        max-height: 360px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="topbar">
      <div class="topbar-links">
        <a class="chip-link" href="/">
          <i data-lucide="arrow-left" style="width:14px;height:14px;"></i>
          Portfolio
        </a>
        <a class="chip-link" href="https://github.com/Liranatt/garmin-project" target="_blank" rel="noopener noreferrer">
          <i data-lucide="github" style="width:14px;height:14px;"></i>
          Project Repo
        </a>
      </div>
      <span id="statusBadge" class="status loading">
        <i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>
        Connecting
      </span>
    </header>

    <section class="hero">
      <div class="hero-inner">
        <div>
          <h1>Garmin Health Intelligence Dashboard v3</h1>
          <p>
            Deterministic statistics first, multi-agent reasoning second. This page mirrors your Streamlit v3
            structure and consumes your Heroku API for snapshot metrics, insights, and interactive agent chat.
          </p>
        </div>
        <div class="hero-kpis">
          <article class="hero-kpi">
            <span class="label">Resting HR</span>
            <strong class="value" id="heroRestHr">--</strong>
          </article>
          <article class="hero-kpi">
            <span class="label">HRV</span>
            <strong class="value" id="heroHrv">--</strong>
          </article>
          <article class="hero-kpi">
            <span class="label">Sleep Score</span>
            <strong class="value" id="heroSleep">--</strong>
          </article>
          <article class="hero-kpi">
            <span class="label">Body Battery</span>
            <strong class="value" id="heroBattery">--</strong>
          </article>
        </div>
      </div>
    </section>

    <nav class="mode-nav" aria-label="Dashboard sections">
      <a class="mode-pill" href="#snapshot">Overview</a>
      <a class="mode-pill" href="#insights">Insights</a>
      <a class="mode-pill" href="#chat">Agent Chat</a>
      <a class="mode-pill" href="#analytics" data-analytics-view="trends">Trends</a>
      <a class="mode-pill" href="#analytics" data-analytics-view="correlations">Correlations</a>
      <a class="mode-pill" href="#analytics" data-analytics-view="workouts">Workout Progress</a>
    </nav>

    <main class="layout">
      <section class="stack">

        <article id="snapshot" class="card">
          <header class="card-head">
            <h2 class="card-title">
              <i data-lucide="heart-pulse" style="width:17px;height:17px;"></i>
              Latest Snapshot
            </h2>
            <button class="button ghost" id="refreshSnapshotBtn" type="button">
              <i data-lucide="refresh-cw" style="width:14px;height:14px;"></i>
              Refresh
            </button>
          </header>
          <div class="card-body">
            <div id="snapshotStatus" class="loading-row">
              <i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>
              Loading snapshot metrics...
            </div>
            <div class="metrics-grid" id="metricsGrid" hidden>
              <article class="metric">
                <div class="metric-label">Resting Heart Rate</div>
                <div class="metric-value" id="mRestHr">--</div>
                <div class="metric-meta">bpm</div>
              </article>
              <article class="metric">
                <div class="metric-label">HRV</div>
                <div class="metric-value" id="mHrv">--</div>
                <div class="metric-meta">ms</div>
              </article>
              <article class="metric">
                <div class="metric-label">Sleep Score</div>
                <div class="metric-value" id="mSleep">--</div>
                <div class="metric-meta">0-100</div>
              </article>
              <article class="metric">
                <div class="metric-label">Body Battery</div>
                <div class="metric-value" id="mBattery">--</div>
                <div class="metric-meta">0-100</div>
              </article>
              <article class="metric">
                <div class="metric-label">Stress</div>
                <div class="metric-value" id="mStress">--</div>
                <div class="metric-meta">daily index</div>
              </article>
              <article class="metric">
                <div class="metric-label">Training Load</div>
                <div class="metric-value" id="mLoad">--</div>
                <div class="metric-meta">7-day</div>
              </article>
            </div>
          </div>
        </article>

        <article id="analytics" class="card">
          <header class="card-head">
            <h2 class="card-title">
              <i data-lucide="line-chart" style="width:17px;height:17px;"></i>
              Analytics Workspace
            </h2>
            <button class="button ghost" id="refreshAnalyticsBtn" type="button">
              <i data-lucide="refresh-cw" style="width:14px;height:14px;"></i>
              Refresh
            </button>
          </header>
          <div class="card-body">
            <div class="analytics-toolbar">
              <div id="analyticsTabs" class="analytics-tabs" role="tablist" aria-label="Analytics views">
                <button class="analytics-tab is-active" type="button" data-analytics-view="trends">Trends</button>
                <button class="analytics-tab" type="button" data-analytics-view="correlations">Correlations</button>
                <button class="analytics-tab" type="button" data-analytics-view="workouts">Workout Progress</button>
              </div>
              <div class="analytics-side">
                <label for="rangeSelect">Window</label>
                <select id="rangeSelect" aria-label="Analytics timeframe"></select>
              </div>
            </div>
            <div id="historyStatus" class="loading-row trend-status">
              <i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>
              Loading analytics...
            </div>

            <section id="analyticsTrends" class="analytics-panel">
              <div class="trend-grid" id="trendGrid" hidden></div>
            </section>

            <section id="analyticsCorrelations" class="analytics-panel" hidden>
              <div id="correlationSummary" class="help"></div>
              <div class="table-wrap" id="correlationTableWrap"></div>
            </section>

            <section id="analyticsWorkouts" class="analytics-panel" hidden>
              <div id="workoutSummary" class="help"></div>
              <div class="trend-grid" id="workoutTrendGrid"></div>
              <div class="table-wrap" id="workoutTableWrap"></div>
            </section>
          </div>
        </article>

        <article id="insights" class="card">
          <header class="card-head">
            <h2 class="card-title">
              <i data-lucide="sparkles" style="width:17px;height:17px;"></i>
              Agent Insights
            </h2>
            <button class="button ghost" id="refreshInsightsBtn" type="button">
              <i data-lucide="refresh-cw" style="width:14px;height:14px;"></i>
              Refresh
            </button>
          </header>
          <div class="card-body">
            <div id="insightMain" class="insight-main" hidden></div>
            <div id="insightsList" class="insights">
              <div class="loading-row">
                <i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>
                Loading latest insights...
              </div>
            </div>
          </div>
        </article>
      </section>

      <section id="chat" class="card">
        <header class="card-head">
          <h2 class="card-title">
            <i data-lucide="messages-square" style="width:17px;height:17px;"></i>
            Interactive Agent Chat
          </h2>
        </header>
        <div class="card-body chat-wrap">
          <div id="chatLog" class="chat-log">
            <div class="msg system">Ask the agent about sleep patterns, training load, correlations, or recovery trends.</div>
          </div>

          <form id="chatForm" class="chat-form">
            <textarea id="chatInput" placeholder="Example: Why did my recovery score drop this week?"></textarea>
            <div class="chat-actions">
              <button class="button primary" type="submit" id="sendBtn">
                <i data-lucide="send" style="width:14px;height:14px;"></i>
                Send
              </button>
              <button class="button ghost" type="button" id="clearChatBtn">
                <i data-lucide="trash-2" style="width:14px;height:14px;"></i>
                Clear
              </button>
            </div>
          </form>

          <p class="footer-note">
            This UI is Streamlit-free. It talks directly to your backend API so you can fully host on Heroku.
          </p>
        </div>
      </section>
    </main>

  </div>

  <script>
    const DEFAULT_API_BASE = "https://garmin-health-liran-f16faec73fc5.herokuapp.com";
    const HISTORY_START_DATE = "2026-02-01";
    const ANALYTICS_VIEWS = ["trends", "correlations", "workouts"];
    const RANGE_OPTIONS = [
      { days: 7, label: "1 week" },
      { days: 14, label: "2 weeks" },
      { days: 21, label: "3 weeks" },
      { days: 30, label: "1 month" },
      { days: 60, label: "2 months" },
      { days: 90, label: "3 months" },
      { days: 180, label: "6 months" },
      { days: 270, label: "9 months" },
      { days: 365, label: "1 year" }
    ];

    const state = {
      apiBase: DEFAULT_API_BASE,
      selectedRangeDays: 60,
      analyticsView: "trends",
      snapshot: null,
      insights: { main: null, agents: [] },
      history: [],
      workouts: [],
      workoutSummary: null,
      historyError: "",
      workoutError: ""
    };

    const el = {
      statusBadge: document.getElementById("statusBadge"),
      refreshSnapshotBtn: document.getElementById("refreshSnapshotBtn"),
      refreshAnalyticsBtn: document.getElementById("refreshAnalyticsBtn"),
      refreshInsightsBtn: document.getElementById("refreshInsightsBtn"),
      rangeSelect: document.getElementById("rangeSelect"),
      snapshotStatus: document.getElementById("snapshotStatus"),
      metricsGrid: document.getElementById("metricsGrid"),
      historyStatus: document.getElementById("historyStatus"),
      trendGrid: document.getElementById("trendGrid"),
      analyticsTrends: document.getElementById("analyticsTrends"),
      analyticsCorrelations: document.getElementById("analyticsCorrelations"),
      analyticsWorkouts: document.getElementById("analyticsWorkouts"),
      correlationSummary: document.getElementById("correlationSummary"),
      correlationTableWrap: document.getElementById("correlationTableWrap"),
      workoutSummary: document.getElementById("workoutSummary"),
      workoutTrendGrid: document.getElementById("workoutTrendGrid"),
      workoutTableWrap: document.getElementById("workoutTableWrap"),
      insightMain: document.getElementById("insightMain"),
      insightsList: document.getElementById("insightsList"),
      chatForm: document.getElementById("chatForm"),
      chatInput: document.getElementById("chatInput"),
      chatLog: document.getElementById("chatLog"),
      sendBtn: document.getElementById("sendBtn"),
      clearChatBtn: document.getElementById("clearChatBtn"),
      heroRestHr: document.getElementById("heroRestHr"),
      heroHrv: document.getElementById("heroHrv"),
      heroSleep: document.getElementById("heroSleep"),
      heroBattery: document.getElementById("heroBattery"),
      mRestHr: document.getElementById("mRestHr"),
      mHrv: document.getElementById("mHrv"),
      mSleep: document.getElementById("mSleep"),
      mBattery: document.getElementById("mBattery"),
      mStress: document.getElementById("mStress"),
      mLoad: document.getElementById("mLoad")
    };



    function endpoint(path) {
      return `${state.apiBase}${path}`;
    }

    function fmt(value, fallback = "--") {
      if (value === null || value === undefined || value === "") {
        return fallback;
      }
      if (typeof value === "number" && Number.isFinite(value)) {
        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }
      return String(value);
    }

    function setStatus(kind, text, icon = "activity") {
      el.statusBadge.className = `status ${kind}`;
      el.statusBadge.innerHTML = `<i data-lucide="${icon}" style="width:14px;height:14px;"></i>${text}`;
      lucide.createIcons();
    }

    function rangeLabel(days) {
      const option = RANGE_OPTIONS.find((item) => item.days === days);
      return option ? option.label : `${days} days`;
    }

    function formatDate(value) {
      if (!value) {
        return "";
      }
      const ts = Date.parse(String(value));
      if (!Number.isFinite(ts)) {
        return String(value);
      }
      return new Date(ts).toISOString().slice(0, 10);
    }

    function messageFromError(error) {
      if (error instanceof Error && error.message) {
        return error.message;
      }
      return String(error || "Unknown error");
    }

    function findFirst(source, keys) {
      for (const key of keys) {
        const value = source?.[key];
        if (value !== undefined && value !== null && value !== "") {
          return value;
        }
      }
      return null;
    }

    function normalizeSnapshot(data) {
      const source = data?.snapshot || data?.data || data || {};
      return {
        restingHr: findFirst(source, ["resting_hr", "restingHeartRate", "rhr", "resting_hr_avg"]),
        hrv: findFirst(source, ["hrv", "hrv_ms", "rmssd"]),
        sleep: findFirst(source, ["sleep_score", "sleepScore", "sleep"]),
        battery: findFirst(source, ["body_battery", "bodyBattery", "battery"]),
        stress: findFirst(source, ["stress", "stress_score", "avg_stress"]),
        load: findFirst(source, ["training_load", "load", "acute_load", "seven_day_load"]),
        timestamp: findFirst(source, ["timestamp", "created_at", "date", "as_of"])
      };
    }

    function numberOrNull(value) {
      const n = Number(value);
      return Number.isFinite(n) ? n : null;
    }

    function average(values) {
      if (!values.length) {
        return null;
      }
      return values.reduce((acc, value) => acc + value, 0) / values.length;
    }

    function normalizeHistory(payload) {
      const rows = Array.isArray(payload)
        ? payload
        : Array.isArray(payload?.data)
          ? payload.data
          : Array.isArray(payload?.history)
            ? payload.history
            : [];

      const normalized = rows.map((row) => ({
        date: formatDate(findFirst(row, ["date", "timestamp", "as_of"])),
        restingHr: numberOrNull(findFirst(row, ["resting_hr", "restingHr", "rhr"])),
        hrv: numberOrNull(findFirst(row, ["hrv", "hrv_last_night", "hrv_ms", "rmssd"])),
        sleep: numberOrNull(findFirst(row, ["sleep_score", "sleepScore", "sleep"])),
        stress: numberOrNull(findFirst(row, ["stress", "stress_level", "stress_score", "avg_stress"])),
        battery: numberOrNull(findFirst(row, ["battery", "body_battery", "bb_peak"])),
        load: numberOrNull(findFirst(row, ["training_load", "daily_load_acute", "load", "acute_load"]))
      }));

      const startTs = Date.parse(HISTORY_START_DATE);
      return normalized
        .filter((row) => row.date)
        .filter((row) => {
          const rowTs = Date.parse(String(row.date));
          if (Number.isFinite(startTs) && Number.isFinite(rowTs) && rowTs < startTs) {
            return false;
          }
          return [row.restingHr, row.hrv, row.sleep, row.stress, row.battery, row.load]
            .some((value) => value !== null && value !== undefined);
        })
        .sort((a, b) => String(a.date).localeCompare(String(b.date)));
    }

    function sparklineModel(values, width = 320, height = 68, pad = 7) {
      const points = values.filter((value) => value !== null && value !== undefined);
      if (points.length === 0) {
        return { path: "", lastX: 0, lastY: 0 };
      }

      const min = Math.min(...points);
      const max = Math.max(...points);
      const range = max - min || 1;
      const step = points.length > 1 ? (width - (pad * 2)) / (points.length - 1) : 0;

      const mapped = points.map((value, index) => {
        const x = pad + (index * step);
        const y = height - pad - (((value - min) / range) * (height - (pad * 2)));
        return { x, y };
      });

      const path = mapped.map((point, index) => `${index === 0 ? "M" : "L"} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`).join(" ");
      const last = mapped[mapped.length - 1];
      return { path, lastX: last.x, lastY: last.y };
    }

    function trendDelta(values) {
      const clean = values.filter((value) => value !== null && value !== undefined);
      if (clean.length < 6) {
        return null;
      }
      const chunk = Math.max(3, Math.floor(clean.length / 3));
      const recent = average(clean.slice(-chunk));
      const previous = average(clean.slice(0, chunk));
      if (recent === null || previous === null || previous === 0) {
        return null;
      }
      return ((recent - previous) / Math.abs(previous)) * 100;
    }

    function trendClass(delta, higherIsBetter) {
      if (delta === null || Math.abs(delta) < 0.5) {
        return "flat";
      }
      if (higherIsBetter) {
        return delta >= 0 ? "up" : "down";
      }
      return delta >= 0 ? "down" : "up";
    }

    function renderHistory(rows) {
      state.history = rows;
      if (!rows.length) {
        el.trendGrid.hidden = true;
        el.historyStatus.innerHTML = '<span class="empty">No daily history rows returned yet.</span>';
        return;
      }

      const metrics = [
        { key: "restingHr", label: "Resting HR", unit: "bpm", higherIsBetter: false },
        { key: "hrv", label: "HRV", unit: "ms", higherIsBetter: true },
        { key: "sleep", label: "Sleep Score", unit: "", higherIsBetter: true },
        { key: "stress", label: "Stress", unit: "", higherIsBetter: false },
        { key: "battery", label: "Body Battery", unit: "", higherIsBetter: true },
        { key: "load", label: "Training Load", unit: "", higherIsBetter: true }
      ];

      const cards = metrics.map((metric) => {
        const values = rows.map((row) => row[metric.key]).filter((value) => value !== null && value !== undefined);
        if (!values.length) {
          return `
            <article class="trend-card">
              <div class="trend-top">
                <span class="trend-label">${metric.label}</span>
                <strong class="trend-value">--</strong>
              </div>
              <div class="trend-delta flat">No data</div>
            </article>
          `;
        }

        const latest = values[values.length - 1];
        const spark = sparklineModel(values);
        const delta = trendDelta(values);
        const klass = trendClass(delta, metric.higherIsBetter);
        const deltaText = delta === null
          ? "Need at least 6 days"
          : `${delta > 0 ? "+" : ""}${delta.toFixed(1)}% across this window`;

        return `
          <article class="trend-card">
            <div class="trend-top">
              <span class="trend-label">${metric.label}</span>
              <strong class="trend-value">${fmt(latest)}${metric.unit ? ` ${metric.unit}` : ""}</strong>
            </div>
            <svg class="spark" viewBox="0 0 320 68" preserveAspectRatio="none">
              <path d="${spark.path}"></path>
              <circle cx="${spark.lastX.toFixed(2)}" cy="${spark.lastY.toFixed(2)}" r="3"></circle>
            </svg>
            <div class="trend-delta ${klass}">${escapeHtml(deltaText)}</div>
          </article>
        `;
      }).join("");

      const firstDate = rows[0].date;
      const lastDate = rows[rows.length - 1].date;
      el.historyStatus.textContent = `Loaded ${rows.length} daily rows from ${firstDate} to ${lastDate}`;
      el.trendGrid.innerHTML = cards;
      el.trendGrid.hidden = false;
    }

    function renderHistoryError(message) {
      el.trendGrid.hidden = true;
      el.historyStatus.innerHTML = `<span class="empty">${escapeHtml(message)}</span>`;
    }

    function normalizeWorkouts(payload) {
      const rows = Array.isArray(payload?.data)
        ? payload.data
        : Array.isArray(payload)
          ? payload
          : [];

      const startTs = Date.parse(HISTORY_START_DATE);
      return rows
        .map((row) => {
          const durationMin = numberOrNull(findFirst(row, ["duration_min", "durationMin"])) ??
            (() => {
              const seconds = numberOrNull(findFirst(row, ["duration_sec", "durationSec"]));
              return seconds ? seconds / 60 : null;
            })();
          const distanceKm = numberOrNull(findFirst(row, ["distance_km", "distanceKm"])) ??
            (() => {
              const meters = numberOrNull(findFirst(row, ["distance_m", "distanceM"]));
              return meters ? meters / 1000 : null;
            })();

          return {
            date: formatDate(findFirst(row, ["date", "timestamp"])),
            activityName: findFirst(row, ["activity_name", "activityName"]) || "Workout",
            activityType: findFirst(row, ["activity_type", "activityType", "sport_type", "sportType"]) || "unknown",
            durationMin,
            distanceKm,
            avgHr: numberOrNull(findFirst(row, ["average_hr", "avg_hr", "avgHr"])),
            speedKph: numberOrNull(findFirst(row, ["speed_kph", "speedKph"])),
            cadence: numberOrNull(findFirst(row, ["avg_cadence", "avgCadence", "cadence"])),
            trainingLoad: numberOrNull(findFirst(row, ["training_load", "trainingLoad"]))
          };
        })
        .filter((row) => row.date)
        .filter((row) => {
          const rowTs = Date.parse(row.date);
          return !Number.isFinite(startTs) || !Number.isFinite(rowTs) || rowTs >= startTs;
        })
        .sort((a, b) => a.date.localeCompare(b.date));
    }

    function setAnalyticsView(view) {
      if (!ANALYTICS_VIEWS.includes(view)) {
        return;
      }
      state.analyticsView = view;

      const panelMap = {
        trends: el.analyticsTrends,
        correlations: el.analyticsCorrelations,
        workouts: el.analyticsWorkouts
      };
      Object.entries(panelMap).forEach(([name, node]) => {
        if (node) {
          node.hidden = name !== state.analyticsView;
        }
      });

      document.querySelectorAll("[data-analytics-view]").forEach((node) => {
        node.classList.toggle("is-active", node.dataset.analyticsView === state.analyticsView);
      });

      renderAnalyticsView();
    }

    function renderAnalyticsStatus() {
      const parts = [`Window: ${rangeLabel(state.selectedRangeDays)}`];
      if (state.historyError) {
        parts.push("Trends unavailable");
      } else {
        parts.push(`${state.history.length} daily rows`);
      }
      if (state.workoutError) {
        parts.push("Workouts unavailable");
      } else {
        parts.push(`${state.workouts.length} workouts`);
      }
      el.historyStatus.textContent = parts.join(" | ");
    }
    function pearson(valuesA, valuesB) {
      const pairs = [];
      for (let i = 0; i < valuesA.length; i += 1) {
        const a = valuesA[i];
        const b = valuesB[i];
        if (a === null || b === null || a === undefined || b === undefined) {
          continue;
        }
        pairs.push([a, b]);
      }
      if (pairs.length < 5) {
        return null;
      }

      const xs = pairs.map((item) => item[0]);
      const ys = pairs.map((item) => item[1]);
      const meanX = average(xs);
      const meanY = average(ys);
      if (meanX === null || meanY === null) {
        return null;
      }

      let numerator = 0;
      let denX = 0;
      let denY = 0;
      for (let i = 0; i < xs.length; i += 1) {
        const dx = xs[i] - meanX;
        const dy = ys[i] - meanY;
        numerator += dx * dy;
        denX += dx * dx;
        denY += dy * dy;
      }
      if (denX === 0 || denY === 0) {
        return null;
      }
      return numerator / Math.sqrt(denX * denY);
    }

    function corrCellStyle(value, diagonal = false) {
      if (diagonal) {
        return "background: rgba(255,255,255,0.08);";
      }
      if (value === null) {
        return "background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.4);";
      }
      const alpha = Math.min(0.46, 0.12 + (Math.abs(value) * 0.34));
      if (value >= 0) {
        return `background: rgba(74,222,128,${alpha.toFixed(3)});`;
      }
      return `background: rgba(251,113,133,${alpha.toFixed(3)});`;
    }

    function renderCorrelationMatrix(rows) {
      if (state.historyError) {
        el.correlationSummary.innerHTML = `<span class="empty">${escapeHtml(state.historyError)}</span>`;
        el.correlationTableWrap.innerHTML = "";
        return;
      }
      const metrics = [
        { key: "restingHr", label: "Resting HR" },
        { key: "hrv", label: "HRV" },
        { key: "sleep", label: "Sleep Score" },
        { key: "stress", label: "Stress" },
        { key: "battery", label: "Body Battery" },
        { key: "load", label: "Training Load" }
      ];

      if (rows.length < 5) {
        el.correlationSummary.innerHTML = '<span class="empty">Need at least 5 daily rows for correlation analysis.</span>';
        el.correlationTableWrap.innerHTML = "";
        return;
      }

      const matrix = metrics.map((left) => metrics.map((right) => (
        left.key === right.key ? 1 : pearson(rows.map((row) => row[left.key]), rows.map((row) => row[right.key]))
      )));

      let strongest = null;
      for (let i = 0; i < metrics.length; i += 1) {
        for (let j = i + 1; j < metrics.length; j += 1) {
          const value = matrix[i][j];
          if (value === null) {
            continue;
          }
          if (!strongest || Math.abs(value) > Math.abs(strongest.value)) {
            strongest = { left: metrics[i].label, right: metrics[j].label, value };
          }
        }
      }

      if (strongest) {
        const strength = Math.abs(strongest.value) >= 0.7
          ? "strong"
          : Math.abs(strongest.value) >= 0.4 ? "moderate" : "weak";
        const direction = strongest.value >= 0 ? "move together" : "move in opposite directions";
        el.correlationSummary.textContent =
          `Most notable relationship: ${strongest.left} and ${strongest.right} (${strength}, ${direction}, r=${strongest.value.toFixed(2)}).`;
      } else {
        el.correlationSummary.textContent = "No clear correlation pattern in this window.";
      }

      const header = metrics.map((metric) => `<th>${escapeHtml(metric.label)}</th>`).join("");
      const body = metrics.map((metric, rowIndex) => {
        const cells = metrics.map((_, colIndex) => {
          const value = matrix[rowIndex][colIndex];
          const text = value === null ? "--" : value.toFixed(2);
          return `<td class="corr-cell" style="${corrCellStyle(value, rowIndex === colIndex)}">${text}</td>`;
        }).join("");
        return `<tr><th>${escapeHtml(metric.label)}</th>${cells}</tr>`;
      }).join("");

      el.correlationTableWrap.innerHTML = `
        <table>
          <thead>
            <tr><th>Metric</th>${header}</tr>
          </thead>
          <tbody>${body}</tbody>
        </table>
      `;
    }

    function renderWorkoutProgress(rows) {
      if (state.workoutError) {
        el.workoutSummary.innerHTML = `<span class="empty">${escapeHtml(state.workoutError)}</span>`;
        el.workoutTrendGrid.innerHTML = "";
        el.workoutTableWrap.innerHTML = "";
        return;
      }

      if (!rows.length) {
        el.workoutSummary.innerHTML = '<span class="empty">No workouts found in this period.</span>';
        el.workoutTrendGrid.innerHTML = "";
        el.workoutTableWrap.innerHTML = "";
        return;
      }

      const summary = state.workoutSummary || {};
      const types = Array.isArray(summary.activity_types) ? summary.activity_types : [];
      el.workoutSummary.innerHTML = `
        <strong style="color:#fff;">${rows.length} workouts in ${escapeHtml(rangeLabel(state.selectedRangeDays))}.</strong>
        <br>${escapeHtml(types.length ? `Types: ${types.slice(0, 5).join(", ")}` : "Types: mixed")}
        <br><span style="color:rgba(255,255,255,0.58);font-size:12px;">${escapeHtml(summary?.strength_proxy_trend?.note || "Strength progression currently uses workout load/duration proxies.")}</span>
      `;

      const metrics = [
        { key: "avgHr", label: "Workout Avg HR", unit: "bpm", higherIsBetter: false },
        { key: "speedKph", label: "Speed", unit: "km/h", higherIsBetter: true },
        { key: "cadence", label: "Cadence", unit: "spm", higherIsBetter: true },
        { key: "trainingLoad", label: "Training Load", unit: "", higherIsBetter: true }
      ];

      el.workoutTrendGrid.innerHTML = metrics.map((metric) => {
        const values = rows.map((row) => row[metric.key]).filter((value) => value !== null && value !== undefined);
        if (!values.length) {
          return `
            <article class="trend-card">
              <div class="trend-top">
                <span class="trend-label">${metric.label}</span>
                <strong class="trend-value">--</strong>
              </div>
              <div class="trend-delta flat">No data</div>
            </article>
          `;
        }

        const latest = values[values.length - 1];
        const spark = sparklineModel(values);
        const delta = trendDelta(values);
        const klass = trendClass(delta, metric.higherIsBetter);
        const deltaText = delta === null ? "Need at least 6 sessions" : `${delta > 0 ? "+" : ""}${delta.toFixed(1)}% in this window`;

        return `
          <article class="trend-card">
            <div class="trend-top">
              <span class="trend-label">${metric.label}</span>
              <strong class="trend-value">${fmt(latest)}${metric.unit ? ` ${metric.unit}` : ""}</strong>
            </div>
            <svg class="spark" viewBox="0 0 320 68" preserveAspectRatio="none">
              <path d="${spark.path}"></path>
              <circle cx="${spark.lastX.toFixed(2)}" cy="${spark.lastY.toFixed(2)}" r="3"></circle>
            </svg>
            <div class="trend-delta ${klass}">${escapeHtml(deltaText)}</div>
          </article>
        `;
      }).join("");

      const recent = rows.slice(-50).reverse();
      const tableRows = recent.map((row) => `
        <tr>
          <td>${escapeHtml(row.date)}</td>
          <td>${escapeHtml(row.activityName)}</td>
          <td>${escapeHtml(String(row.activityType).replace(/_/g, " "))}</td>
          <td>${fmt(row.durationMin)}</td>
          <td>${fmt(row.distanceKm)}</td>
          <td>${fmt(row.avgHr)}</td>
          <td>${fmt(row.speedKph)}</td>
          <td>${fmt(row.cadence)}</td>
          <td>${fmt(row.trainingLoad)}</td>
        </tr>
      `).join("");

      el.workoutTableWrap.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Date</th><th>Workout</th><th>Type</th><th>Min</th><th>Km</th>
              <th>Avg HR</th><th>Speed</th><th>Cadence</th><th>Load</th>
            </tr>
          </thead>
          <tbody>${tableRows}</tbody>
        </table>
      `;
    }

    function renderAnalyticsView() {
      renderAnalyticsStatus();
      if (state.analyticsView === "trends") {
        if (state.historyError) {
          renderHistoryError(state.historyError);
          return;
        }
        renderHistory(state.history);
        return;
      }
      if (state.analyticsView === "correlations") {
        renderCorrelationMatrix(state.history);
        return;
      }
      renderWorkoutProgress(state.workouts);
    }

    function renderSnapshot(metrics) {
      state.snapshot = metrics;

      el.mRestHr.textContent = fmt(metrics.restingHr);
      el.mHrv.textContent = fmt(metrics.hrv);
      el.mSleep.textContent = fmt(metrics.sleep);
      el.mBattery.textContent = fmt(metrics.battery);
      el.mStress.textContent = fmt(metrics.stress);
      el.mLoad.textContent = fmt(metrics.load);

      el.heroRestHr.textContent = fmt(metrics.restingHr);
      el.heroHrv.textContent = fmt(metrics.hrv);
      el.heroSleep.textContent = fmt(metrics.sleep);
      el.heroBattery.textContent = fmt(metrics.battery);

      el.snapshotStatus.innerHTML = metrics.timestamp
        ? `As of ${fmt(metrics.timestamp)}`
        : "Latest available snapshot";
      el.metricsGrid.hidden = false;
    }

    function renderSnapshotError(message) {
      el.metricsGrid.hidden = true;
      el.snapshotStatus.innerHTML = `<span class="empty">${message}</span>`;
    }

    function normalizeInsights(payload) {
      const raw = Array.isArray(payload)
        ? payload
        : Array.isArray(payload?.insights)
          ? payload.insights
          : Array.isArray(payload?.data)
            ? payload.data
            : (payload?.insight || payload?.message || payload?.text)
              ? [payload]
              : [];

      return expandCompositeInsights(raw);
    }

    function rawInsightText(item) {
      if (typeof item === "string") {
        return item;
      }
      return findFirst(item, ["insight", "message", "text", "summary", "content"]) || "";
    }

    function rawInsightAgent(item) {
      if (typeof item === "string") {
        return "agent";
      }
      return findFirst(item, ["agent", "agent_name", "source", "role"]) || "agent";
    }

    function rawInsightTime(item) {
      if (typeof item === "string") {
        return "";
      }
      return findFirst(item, ["timestamp", "created_at", "date", "time"]) || "";
    }

    function cleanAgentText(text) {
      return String(text || "")
        .replace(/\r/g, "")
        .replace(/```[\s\S]*?```/g, "\n")
        .replace(/^\s*\|.*\|\s*$/gm, "")
        .replace(/^\s*[-=]{3,}\s*$/gm, "")
        .replace(/^\s*(SELECT|FROM|WHERE|JOIN|ORDER BY|GROUP BY|LIMIT|INSERT|UPDATE|DELETE)\b.*$/gim, "")
        .replace(/\n{3,}/g, "\n\n")
        .trim();
    }

    function looksLikeNoise(line) {
      const text = String(line || "").trim();
      if (!text) {
        return true;
      }

      const lower = text.toLowerCase();
      if (/^[\d\s.,:%()+\-]+$/.test(text)) {
        return true;
      }
      if (/\b(select|from|where|join|order by|group by|limit|insert|update|delete)\b/.test(lower)) {
        return true;
      }
      if (/^\s*[\[{].*[\]}]\s*$/.test(text)) {
        return true;
      }

      const digits = (text.match(/\d/g) || []).length;
      const punctuation = (text.match(/[,;:|]/g) || []).length;
      const digitDensity = digits / Math.max(text.length, 1);
      if (digitDensity > 0.22 && !/(sleep|hrv|stress|recover|training|workout|recommend|action|improve|decrease|increase|load|battery)/i.test(text)) {
        return true;
      }
      if (digits >= 8 && punctuation >= 5) {
        return true;
      }

      return false;
    }

    function splitInsightCandidates(text) {
      return cleanAgentText(text)
        .split(/\n+/)
        .flatMap((line) => line.split(/[.!?]\s+/))
        .map((line) => line.replace(/^[\-*]\s*/, "").trim())
        .filter((line) => line.length >= 25);
    }

    function scoreInsightCandidate(line) {
      const text = String(line || "").trim();
      const lower = text.toLowerCase();
      let score = 0;

      if (/(recommend|should|focus|prioritize|aim|try|keep|reduce|increase|avoid|improve|sleep|recover|training|stress|hrv|battery|load)/.test(lower)) {
        score += 3;
      }
      if (/(because|indicates|suggests|linked|correlat|therefore|which means|driven by)/.test(lower)) {
        score += 2;
      }
      if (text.length >= 45 && text.length <= 190) {
        score += 1;
      }
      if (looksLikeNoise(text)) {
        score -= 4;
      }

      const digits = (text.match(/\d/g) || []).length;
      if (digits > 6) {
        score -= 1;
      }

      return score;
    }

    function distillInsightText(text, maxItems = 3) {
      const ranked = splitInsightCandidates(text)
        .map((line) => ({ line, score: scoreInsightCandidate(line) }))
        .filter((item) => item.score > -1)
        .sort((a, b) => b.score - a.score);

      const selected = [];
      for (const item of ranked) {
        const normalized = item.line.toLowerCase().replace(/[^a-z0-9 ]+/g, " ").replace(/\s+/g, " ").trim();
        if (!normalized) {
          continue;
        }

        const tooSimilar = selected.some((existing) => {
          const base = existing.normalized.slice(0, 28);
          return normalized.includes(base) || existing.normalized.includes(normalized.slice(0, 28));
        });
        if (tooSimilar) {
          continue;
        }

        selected.push({ line: item.line, normalized });
        if (selected.length >= maxItems) {
          break;
        }
      }

      if (!selected.length) {
        return "";
      }

      return selected.map((item) => `- ${item.line}`).join("\n");
    }

    function formatChatReply(text) {
      const clean = cleanAgentText(text);
      if (!clean) {
        return "No response from agent.";
      }

      const lower = clean.toLowerCase();
      const isBackendFallback =
        lower.includes("ai chat model is unavailable") ||
        lower.includes("your question was:");

      // Preserve backend fallback and concise answers as-is.
      if (isBackendFallback || clean.length <= 420) {
        return clean;
      }

      const distilled = distillInsightText(clean, 3);
      if (distilled) {
        return `Key takeaways:\n${distilled}`;
      }

      return summarizeInsightText(clean, 320);
    }

    function summarizeInsightText(text, maxLen = 320) {
      const cleaned = cleanAgentText(text);
      const blocks = cleaned.split(/\n\s*\n/).map((part) => part.trim()).filter(Boolean);
      let best = blocks.find((part) => !looksLikeNoise(part) && part.length >= 30) || blocks.find((part) => part.length >= 20) || "";
      best = best.replace(/\s+/g, " ").trim();
      if (best.length <= maxLen) {
        return best;
      }
      return `${best.slice(0, maxLen - 3)}...`;
    }

    function formatSectionTitle(title) {
      return title
        .replace(/_/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function splitReportSections(text) {
      const lines = text.split(/\r?\n/);
      const sections = [];
      let title = "";
      let buffer = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const next = (lines[i + 1] || "").trim();
        const next2 = (lines[i + 2] || "").trim();

        if (/^={8,}$/.test(line) && next && /^={8,}$/.test(next2)) {
          const content = buffer.join("\n").trim();
          if (content) {
            sections.push({
              title: title || "Daily Report",
              content
            });
          }
          title = formatSectionTitle(next);
          buffer = [];
          i += 2;
          continue;
        }

        buffer.push(lines[i]);
      }

      const tail = buffer.join("\n").trim();
      if (tail) {
        sections.push({
          title: title || "Daily Report",
          content: tail
        });
      }

      if (!sections.length && text.trim()) {
        return [{ title: "Daily Report", content: text.trim() }];
      }
      return sections;
    }

    function extractQuickWins(text, timestamp) {
      const lines = text.split(/\r?\n/);
      const wins = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const match = line.match(/^RECOMMENDATION\s*\d*\s*:\s*(.+)$/i);
        if (!match) {
          continue;
        }

        const block = [line];
        let target = "";
        let direction = "";

        for (let j = i + 1; j < lines.length; j++) {
          const look = lines[j].trim();
          if (/^RECOMMENDATION\s*\d*\s*:/i.test(look)) {
            break;
          }
          block.push(lines[j]);
          const targetMatch = look.match(/^TARGET_METRIC\s*:\s*(.+)$/i);
          if (targetMatch) {
            target = targetMatch[1].trim();
          }
          const directionMatch = look.match(/^EXPECTED_DIRECTION\s*:\s*(.+)$/i);
          if (directionMatch) {
            direction = directionMatch[1].trim();
          }
        }

        const summaryParts = [match[1].trim()];
        if (target) {
          summaryParts.push(`Target: ${target}`);
        }
        if (direction) {
          summaryParts.push(`Expected: ${direction}`);
        }

        wins.push({
          agent: "Quick Win",
          summary: summaryParts.join(" | "),
          detail: block.join("\n").trim(),
          timestamp
        });

        if (wins.length >= 3) {
          break;
        }
      }

      return wins;
    }

    function expandCompositeInsights(items) {
      const expanded = [];

      for (const item of items) {
        const text = rawInsightText(item);
        const agent = rawInsightAgent(item);
        const timestamp = rawInsightTime(item);

        if (!text) {
          continue;
        }

        const sections = splitReportSections(text);
        const isComposite = sections.length > 1 || text.length > 1000;

        if (!isComposite) {
          expanded.push(item);
          continue;
        }

        const wins = extractQuickWins(text, timestamp);
        if (wins.length) {
          expanded.push(...wins);
        }

        for (const section of sections) {
          const detail = section.content.trim();
          if (!detail) {
            continue;
          }
          if (/^please provide the pre-computed correlation analysis/i.test(detail)) {
            continue;
          }
          expanded.push({
            agent: section.title || agent,
            summary: summarizeInsightText(detail),
            detail,
            timestamp
          });
        }
      }

      return expanded.slice(0, 12);
    }

    function insightText(item) {
      if (typeof item === "string") {
        return item;
      }
      return findFirst(item, ["summary", "insight", "message", "text", "content"]) || "No text";
    }

    function insightAgent(item) {
      if (typeof item === "string") {
        return "agent";
      }
      return findFirst(item, ["agent", "agent_name", "source", "role"]) || "agent";
    }

    function insightTime(item) {
      if (typeof item === "string") {
        return "";
      }
      return findFirst(item, ["timestamp", "created_at", "date", "time"]) || "";
    }

    function insightDetail(item) {
      if (typeof item === "string") {
        return "";
      }
      return findFirst(item, ["detail", "text", "content", "raw"]) || "";
    }

    function renderInsights(items) {
      const normalized = Array.isArray(items) ? items : [];
      const mainInsight = normalized[0] || null;
      const agentInsights = mainInsight ? normalized.slice(1, 10) : [];
      state.insights = { main: mainInsight, agents: agentInsights };

      if (!mainInsight) {
        el.insightMain.hidden = true;
        el.insightMain.innerHTML = "";
        el.insightsList.innerHTML = '<div class="empty">No insights returned yet. Trigger your pipeline and refresh.</div>';
        return;
      }

      const mainSummaryText = insightText(mainInsight);
      const mainDisplayText = distillInsightText(mainSummaryText, 3) || summarizeInsightText(mainSummaryText, 320) || mainSummaryText;
      const mainSummary = escapeHtml(mainDisplayText).replace(/\n/g, "<br>");
      const mainAgent = escapeHtml(String(insightAgent(mainInsight)).replace(/_/g, " "));
      const mainTime = escapeHtml(insightTime(mainInsight));
      el.insightMain.hidden = false;
      el.insightMain.innerHTML = `
        <h3>${mainAgent}</h3>
        <p>${mainSummary}</p>
        <div class="meta">${mainTime ? `Updated: ${mainTime}` : "Latest synthesized insight"}</div>
      `;

      if (!agentInsights.length) {
        el.insightsList.innerHTML = '<div class="empty">No additional agent sections for this cycle.</div>';
        return;
      }

      const html = agentInsights.map((item) => {
        const summaryText = insightText(item);
        const summaryDisplayText = distillInsightText(summaryText, 2) || summarizeInsightText(summaryText, 220) || summaryText;
        const summary = escapeHtml(summaryDisplayText).replace(/\n/g, "<br>");
        const agent = escapeHtml(String(insightAgent(item)).replace(/_/g, " "));
        const time = escapeHtml(insightTime(item));
        const detailRaw = insightDetail(item);
        const detail = escapeHtml(detailRaw);
        const hasDetail = detailRaw && detailRaw.trim() && detailRaw.trim() !== summaryDisplayText.trim();

        return `
          <article class="insight">
            <div class="insight-top">
              <span class="insight-agent">${agent}</span>
              ${time ? `<span class="insight-time">${time}</span>` : ""}
            </div>
            <p>${summary}</p>
            ${hasDetail ? `
              <details class="insight-detail">
                <summary>View full section</summary>
                <pre>${detail}</pre>
              </details>
            ` : ""}
          </article>
        `;
      }).join("");

      el.insightsList.innerHTML = html;
    }
    function renderInsightsError(message) {
      state.insights = { main: null, agents: [] };
      el.insightMain.hidden = true;
      el.insightMain.innerHTML = "";
      el.insightsList.innerHTML = `<div class="empty">${escapeHtml(message)}</div>`;
    }
    function appendMessage(role, text) {
      const node = document.createElement("div");
      node.className = `msg ${role}`;
      node.textContent = text;
      el.chatLog.appendChild(node);
      el.chatLog.scrollTop = el.chatLog.scrollHeight;
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    async function getJson(path) {
      const response = await fetch(endpoint(path), {
        method: "GET",
        headers: { "Accept": "application/json" },
        mode: "cors"
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const text = await response.text();
      if (!text) {
        return {};
      }

      try {
        return JSON.parse(text);
      } catch {
        return { raw: text };
      }
    }

    async function postJson(path, body) {
      const response = await fetch(endpoint(path), {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body),
        mode: "cors"
      });

      if (!response.ok) {
        const errText = await response.text();
        throw new Error(errText || `HTTP ${response.status}`);
      }

      const text = await response.text();
      if (!text) {
        return {};
      }

      try {
        return JSON.parse(text);
      } catch {
        return { raw: text };
      }
    }

    async function loadHealth() {
      try {
        const result = await getJson("/health-check");
        const statusText =
          findFirst(result, ["status", "message"]) ||
          (Object.keys(result).length ? "Healthy" : "Online");

        if (/wake|boot|starting/i.test(statusText)) {
          setStatus("warm", "Waking up", "clock-3");
        } else {
          setStatus("ok", "Online", "check-circle-2");
        }
      } catch {
        setStatus("fail", "Offline", "x-circle");
      }
    }

    async function loadSnapshot() {
      el.snapshotStatus.innerHTML = '<span class="loading-row"><i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>Loading snapshot metrics...</span>';
      lucide.createIcons();

      try {
        const data = await getJson("/api/v1/snapshot/latest");
        const metrics = normalizeSnapshot(data);
        renderSnapshot(metrics);
      } catch (error) {
        renderSnapshotError(`Could not load snapshot (${error.message}).`);
      }
    }

    async function loadHistory() {
      el.historyStatus.innerHTML = '<span class="loading-row"><i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>Loading analytics...</span>';
      lucide.createIcons();

      state.historyError = "";
      state.workoutError = "";

      const days = Number(state.selectedRangeDays);
      const [historyResult, workoutResult] = await Promise.allSettled([
        getJson(`/api/v1/metrics/history?days=${encodeURIComponent(days)}`),
        getJson(`/api/v1/workouts/progress?days=${encodeURIComponent(days)}`)
      ]);

      if (historyResult.status === "fulfilled") {
        state.history = normalizeHistory(historyResult.value);
      } else {
        state.history = [];
        state.historyError = `Could not load trend history (${messageFromError(historyResult.reason)}).`;
      }

      if (workoutResult.status === "fulfilled") {
        state.workouts = normalizeWorkouts(workoutResult.value);
        state.workoutSummary = workoutResult.value?.summary && typeof workoutResult.value.summary === "object"
          ? workoutResult.value.summary
          : null;
      } else {
        state.workouts = [];
        state.workoutSummary = null;
        state.workoutError = `Could not load workout progress (${messageFromError(workoutResult.reason)}).`;
      }

      renderAnalyticsView();
    }
    async function loadInsights() {
      el.insightsList.innerHTML = '<div class="loading-row"><i data-lucide="loader-2" class="spin" style="width:14px;height:14px;"></i>Loading latest insights...</div>';
      el.insightMain.hidden = true;
      el.insightMain.innerHTML = "";
      lucide.createIcons();

      try {
        const data = await getJson("/api/v1/insights/latest");
        const items = normalizeInsights(data);
        renderInsights(items);
      } catch (error) {
        renderInsightsError(`Could not load insights (${error.message}).`);
      }
    }
    async function sendChat(message) {
      appendMessage("user", message);
      appendMessage("bot", "Thinking...");
      const pendingNode = el.chatLog.lastElementChild;

      try {
        const result = await postJson("/api/v1/chat", { message });
        const reply = findFirst(result, ["answer", "response", "message", "text", "output"]) || "No response field returned by API.";
        pendingNode.textContent = formatChatReply(String(reply));
      } catch (error) {
        pendingNode.textContent = `Request failed: ${error.message}`;
      }
    }

    function initRangeOptions() {
      const options = RANGE_OPTIONS.map((item) => (
        `<option value="${item.days}">${item.label}</option>`
      )).join("");
      el.rangeSelect.innerHTML = options;

      if (!RANGE_OPTIONS.some((item) => item.days === state.selectedRangeDays)) {
        state.selectedRangeDays = RANGE_OPTIONS[0].days;
      }
      el.rangeSelect.value = String(state.selectedRangeDays);
    }

    function initEvents() {
      el.refreshSnapshotBtn.addEventListener("click", loadSnapshot);
      el.refreshAnalyticsBtn.addEventListener("click", loadHistory);
      el.refreshInsightsBtn.addEventListener("click", loadInsights);
      initRangeOptions();

      el.rangeSelect.addEventListener("change", () => {
        const nextDays = Number(el.rangeSelect.value);
        if (!Number.isFinite(nextDays) || nextDays <= 0) {
          return;
        }
        state.selectedRangeDays = nextDays;
        loadHistory();
      });

      document.querySelectorAll("[data-analytics-view]").forEach((node) => {
        node.addEventListener("click", (event) => {
          const view = node.dataset.analyticsView;
          if (!view) {
            return;
          }
          if (node.tagName === "A") {
            event.preventDefault();
            history.replaceState(null, "", "#analytics");
          }
          setAnalyticsView(view);
        });
      });

      el.chatForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const message = el.chatInput.value.trim();
        if (!message) {
          return;
        }

        el.chatInput.value = "";
        el.sendBtn.disabled = true;

        await sendChat(message);

        el.sendBtn.disabled = false;
        el.chatInput.focus();
      });

      el.clearChatBtn.addEventListener("click", () => {
        el.chatLog.innerHTML = '<div class="msg system">Chat cleared.</div>';
      });

      el.chatInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          el.chatForm.requestSubmit();
        }
      });

      setAnalyticsView(state.analyticsView);
    }
    async function boot() {
      await loadHealth();
      await Promise.all([loadSnapshot(), loadHistory(), loadInsights()]);
    }

    lucide.createIcons();
    initEvents();
    boot();
  </script>
</body>
</html>
